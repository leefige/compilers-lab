<Module> test/foo.ll, size is 8
=================================
*** BOTTOM UP PARSING... ***
=================================
---------
<Func> abs: arg i
---------
<Func> foo1: arg i
---------
<Func> foo2: arg i
---------
<Func> foo3: arg i
---------
<Func> bar1: arg i
---------
<Func> bar2: arg i
---------
<Func> bar3: arg i
---------
<Func> interproc: arg i
=================================
*** BOTTOM UP FINISHED ***
=================================
---------
<Func> abs: arg i
---------
<Func> foo1: arg i
Checking with assertions:
(ast-vector
  (= (entry i) true)
  (= (and i) (bvand i #x000003ff))
  (= (idxprom i) ((_ sign_extend 32) (and i)))
  true
  (not (and (bvsge (idxprom i) #x0000000000000000)
            (bvslt (idxprom i) #x0000000000000400))))
GEP arrayidx is safe.
---------
<Func> foo2: arg i
Checking with assertions:
(ast-vector
  (= (entry i) true)
  (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0))
  (= (land.lhs.true i) (and true (= (cmp i) #b1)))
  (= (cmp1 i) (ite (bvslt i #x00000400) #b1 #b0))
  (let ((a!1 (or (and true (= (cmp i) #b0))
                 (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
    (= (if.else i) a!1))
  (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))
  (= (idxprom i) ((_ sign_extend 32) i))
  (and true (= (cmp i) #b1) (= (cmp1 i) #b1))
  (not (and (bvsge (idxprom i) #x0000000000000000)
            (bvslt (idxprom i) #x0000000000000400))))
GEP arrayidx is safe.
---------
<Func> foo3: arg i
Checking with assertions:
(ast-vector
  (= (entry i) true)
  (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0))
  (= (land.lhs.true i) (and true (= (cmp i) #b1)))
  (= (cmp1 i) (ite (bvslt i #x00000400) #b1 #b0))
  (let ((a!1 (or (and true (= (cmp i) #b0))
                 (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
    (= (if.else i) a!1))
  (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))
  (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
        (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (let ((a!3 (or (and true (= (cmp i) #b0)) a!1 a!2)))
    (= (if.end i) a!3)))
  (=> (if.then i) (= (x.0 i) i))
  (=> (if.else i) (= (x.0 i) #x00000000))
  (= (idxprom i) ((_ sign_extend 32) (x.0 i)))
  (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
        (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
    (or (and true (= (cmp i) #b0)) a!1 a!2))
  (not (and (bvsge (idxprom i) #x0000000000000000)
            (bvslt (idxprom i) #x0000000000000400))))
GEP arrayidx is safe.
---------
<Func> bar1: arg i
Checking with assertions:
(ast-vector
  (= (entry i) true)
  (= (and i) (bvand i #x000007ff))
  (= (idxprom i) ((_ sign_extend 32) (and i)))
  true
  (not (and (bvsge (idxprom i) #x0000000000000000)
            (bvslt (idxprom i) #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x00000400)
(define-fun and ((x!0 (_ BitVec 32))) (_ BitVec 32)
  #x00000400)
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  #x0000000000000400)
---------
<Func> bar2: arg i
Checking with assertions:
(ast-vector
  (= (entry i) true)
  (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0))
  (= (land.lhs.true i) (and true (= (cmp i) #b1)))
  (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0))
  (let ((a!1 (or (and true (= (cmp i) #b0))
                 (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
    (= (if.else i) a!1))
  (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))
  (= (idxprom i) ((_ sign_extend 32) i))
  (and true (= (cmp i) #b1) (= (cmp1 i) #b1))
  (not (and (bvsge (idxprom i) #x0000000000000000)
            (bvslt (idxprom i) #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x00000400)
(define-fun if.then ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  #x0000000000000400)
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun if.else ((x!0 (_ BitVec 32))) Bool
  false)
(define-fun cmp ((x!0 (_ BitVec 32))) (_ BitVec 1)
  #b1)
(define-fun land.lhs.true ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun cmp1 ((x!0 (_ BitVec 32))) (_ BitVec 1)
  #b1)
---------
<Func> bar3: arg i
Checking with assertions:
(ast-vector
  (= (entry i) true)
  (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0))
  (= (land.lhs.true i) (and true (= (cmp i) #b1)))
  (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0))
  (let ((a!1 (or (and true (= (cmp i) #b0))
                 (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
    (= (if.else i) a!1))
  (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))
  (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
        (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (let ((a!3 (or (and true (= (cmp i) #b0)) a!1 a!2)))
    (= (if.end i) a!3)))
  (=> (if.then i) (= (x.0 i) i))
  (=> (if.else i) (= (x.0 i) #x00000000))
  (= (idxprom i) ((_ sign_extend 32) (x.0 i)))
  (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
        (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
    (or (and true (= (cmp i) #b0)) a!1 a!2))
  (not (and (bvsge (idxprom i) #x0000000000000000)
            (bvslt (idxprom i) #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x00000400)
(define-fun if.else ((x!0 (_ BitVec 32))) Bool
  false)
(define-fun cmp ((x!0 (_ BitVec 32))) (_ BitVec 1)
  #b1)
(define-fun land.lhs.true ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun if.then ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun cmp1 ((x!0 (_ BitVec 32))) (_ BitVec 1)
  #b1)
(define-fun if.end ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun x.0 ((x!0 (_ BitVec 32))) (_ BitVec 32)
  #x00000400)
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  #x0000000000000400)
---------
<Func> interproc: arg i
Checking with assertions:
(ast-vector
  (= (entry i) true)
  (= (call i) #x00000000)
  (= (cmp i) (ite (bvslt (call i) #x00000400) #b1 #b0))
  (= (if.else i) (and true (= (cmp i) #b0)))
  (= (if.then i) (and true (= (cmp i) #b1)))
  (= (idxprom i) ((_ sign_extend 32) (call i)))
  (and true (= (cmp i) #b1))
  (not (and (bvsge (idxprom i) #x0000000000000000)
            (bvslt (idxprom i) #x0000000000000400))))
GEP arrayidx is safe.
