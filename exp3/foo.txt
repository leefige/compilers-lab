new z3walker
<Module> test/foo.ll, size is 8
---------
<Func> abs: arg i
  <BB> entry
$$$ BB cond: true
    visit icmp
    visit br
  <BB> if.else
$$$ BB cond: (and true (= (cmp i) #b0))
    visit br
  <BB> if.then
$$$ BB cond: (and true (= (cmp i) #b1))
    visit sub
    visit br
  <BB> if.end
$$$ BB cond: (or (and true (= (cmp i) #b0)) (and true (= (cmp i) #b1)))
    visit phi
tar: (sub i)branch cond: (if.then i)
tar: ibranch cond: (if.else i)
---------
<Func> foo1: arg i
  <BB> entry
$$$ BB cond: true
    visit and
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun and ((_ BitVec 32)) (_ BitVec 32))
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (= (entry i) true)))
(assert (forall ((i (_ BitVec 32))) (= (and i) (bvand i #x000003ff))))
(assert (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (and i)))))
(assert true)
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (entry i) true))
  (forall ((i (_ BitVec 32))) (= (and i) (bvand i #x000003ff)))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (and i))))
  true
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
---------
<Func> foo2: arg i
  <BB> entry
$$$ BB cond: true
    visit icmp
    visit br
  <BB> land.lhs.true
$$$ BB cond: (and true (= (cmp i) #b1))
    visit icmp
    visit br
  <BB> if.else
$$$ BB cond: (or (and true (= (cmp i) #b0)) (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))
    visit br
  <BB> if.then
$$$ BB cond: (and true (= (cmp i) #b1) (= (cmp1 i) #b1))
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun land.lhs.true ((_ BitVec 32)) Bool)
(declare-fun cmp1 ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(declare-fun i () (_ BitVec 32))
(assert (forall ((i (_ BitVec 32))) (= (entry i) true)))
(assert (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0))))
(assert (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (and true (= (cmp i) #b1)))))
(assert (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvslt i #x00000400) #b1 #b0))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (or (and true (= (cmp i) #b0))
                 (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
    (= (if.else i) a!1))))
(assert (forall ((i (_ BitVec 32)))
  (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))))
(assert (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) i))))
(assert (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (entry i) true))
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (and true (= (cmp i) #b1))))
  (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvslt i #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (or (and true (= (cmp i) #b0))
                   (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
      (= (if.else i) a!1)))
  (forall ((i (_ BitVec 32)))
    (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1))))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) i)))
  (and true (= (cmp i) #b1) (= (cmp1 i) #b1))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x00000000)
(define-fun cmp1 ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (ite (= x!0 #x00000000) #b1
    (ite (bvsle #x00000400 x!0) #b0 #b1)))
(define-fun cmp ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (ite (= (ite (bvule #x80000000 x!0) #x80000000 #x00000000) #x00000000)
       #b1
       #b0))
(define-fun if.else ((x!0 (_ BitVec 32))) Bool
  (ite (= x!0 #x00000000) false
  (ite (= x!0 #x80000000) true
    (let ((a!1 (or (not (= (cmp x!0) #b1)) (not (= (cmp1 x!0) #b0)))))
      (or (= (cmp x!0) #b0) (not a!1))))))
(define-fun land.lhs.true ((x!0 (_ BitVec 32))) Bool
  (= (ite (bvule #x80000000 x!0) #x80000000 #x00000000) #x00000000))
(define-fun if.then ((x!0 (_ BitVec 32))) Bool
  (ite (= x!0 #x00000000) true
  (ite (= x!0 #x80000000) false
    (let ((a!1 (or (not (= (cmp x!0) #b1)) (not (= (cmp1 x!0) #b1)))))
      (not a!1)))))
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  (ite (= x!0 #x80000000) #xffffffff80000000
    (concat ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            x!0)))
    visit br
  <BB> return
$$$ BB cond: (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
      (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (or (and true (= (cmp i) #b0)) a!1 a!2))
    visit phi
tar: (%0 i)branch cond: (if.then i)
tar: #xffffffffbranch cond: (if.else i)
---------
<Func> foo3: arg i
  <BB> entry
$$$ BB cond: true
    visit icmp
    visit br
  <BB> land.lhs.true
$$$ BB cond: (and true (= (cmp i) #b1))
    visit icmp
    visit br
  <BB> if.else
$$$ BB cond: (or (and true (= (cmp i) #b0)) (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))
    visit br
  <BB> if.then
$$$ BB cond: (and true (= (cmp i) #b1) (= (cmp1 i) #b1))
    visit br
  <BB> if.end
$$$ BB cond: (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
      (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (or (and true (= (cmp i) #b0)) a!1 a!2))
    visit phi
tar: ibranch cond: (if.then i)
tar: #x00000000branch cond: (if.else i)
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun land.lhs.true ((_ BitVec 32)) Bool)
(declare-fun cmp1 ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun if.end ((_ BitVec 32)) Bool)
(declare-fun x.0 ((_ BitVec 32)) (_ BitVec 32))
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(declare-fun i () (_ BitVec 32))
(assert (forall ((i (_ BitVec 32))) (= (entry i) true)))
(assert (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0))))
(assert (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (and true (= (cmp i) #b1)))))
(assert (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvslt i #x00000400) #b1 #b0))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (or (and true (= (cmp i) #b0))
                 (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
    (= (if.else i) a!1))))
(assert (forall ((i (_ BitVec 32)))
  (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
        (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (let ((a!3 (or (and true (= (cmp i) #b0)) a!1 a!2)))
    (= (if.end i) a!3)))))
(assert (forall ((i (_ BitVec 32))) (=> (if.then i) (= (x.0 i) i))))
(assert (forall ((i (_ BitVec 32))) (=> (if.else i) (= (x.0 i) #x00000000))))
(assert (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (x.0 i)))))
(assert (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
      (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (or (and true (= (cmp i) #b0)) a!1 a!2)))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (entry i) true))
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (and true (= (cmp i) #b1))))
  (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvslt i #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (or (and true (= (cmp i) #b0))
                   (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
      (= (if.else i) a!1)))
  (forall ((i (_ BitVec 32)))
    (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
          (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
    (let ((a!3 (or (and true (= (cmp i) #b0)) a!1 a!2)))
      (= (if.end i) a!3))))
  (forall ((i (_ BitVec 32))) (=> (if.then i) (= (x.0 i) i)))
  (forall ((i (_ BitVec 32))) (=> (if.else i) (= (x.0 i) #x00000000)))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (x.0 i))))
  (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
        (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
    (or (and true (= (cmp i) #b0)) a!1 a!2))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
---------
<Func> bar1: arg i
  <BB> entry
$$$ BB cond: true
    visit and
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun and ((_ BitVec 32)) (_ BitVec 32))
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (= (entry i) true)))
(assert (forall ((i (_ BitVec 32))) (= (and i) (bvand i #x000007ff))))
(assert (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (and i)))))
(assert true)
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (entry i) true))
  (forall ((i (_ BitVec 32))) (= (and i) (bvand i #x000007ff)))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (and i))))
  true
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun and ((x!0 (_ BitVec 32))) (_ BitVec 32)
  (ite (= x!0 #x00000400) #x00000400
    (concat #b000000000000000000000 ((_ extract 10 0) x!0))))
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  (ite (= x!0 #x00000400) #x0000000000000400
    (concat ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            (and x!0))))
---------
<Func> bar2: arg i
  <BB> entry
$$$ BB cond: true
    visit icmp
    visit br
  <BB> land.lhs.true
$$$ BB cond: (and true (= (cmp i) #b1))
    visit icmp
    visit br
  <BB> if.else
$$$ BB cond: (or (and true (= (cmp i) #b0)) (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))
    visit br
  <BB> if.then
$$$ BB cond: (and true (= (cmp i) #b1) (= (cmp1 i) #b1))
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun land.lhs.true ((_ BitVec 32)) Bool)
(declare-fun cmp1 ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(declare-fun i () (_ BitVec 32))
(assert (forall ((i (_ BitVec 32))) (= (entry i) true)))
(assert (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0))))
(assert (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (and true (= (cmp i) #b1)))))
(assert (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (or (and true (= (cmp i) #b0))
                 (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
    (= (if.else i) a!1))))
(assert (forall ((i (_ BitVec 32)))
  (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))))
(assert (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) i))))
(assert (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (entry i) true))
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (and true (= (cmp i) #b1))))
  (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (or (and true (= (cmp i) #b0))
                   (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
      (= (if.else i) a!1)))
  (forall ((i (_ BitVec 32)))
    (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1))))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) i)))
  (and true (= (cmp i) #b1) (= (cmp1 i) #b1))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x00000000)
(define-fun cmp1 ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (ite (= x!0 #x00000000) #b1
  (ite (= x!0 #x80000000) #b1
    (ite (bvsle x!0 #x00000400) #b1 #b0))))
(define-fun cmp ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (ite (= (ite (bvule #x80000000 x!0) #x80000000 #x00000000) #x00000000)
       #b1
       #b0))
(define-fun if.else ((x!0 (_ BitVec 32))) Bool
  (ite (= x!0 #x00000000) false
  (ite (= x!0 #x80000000) true
    (let ((a!1 (or (not (= (cmp x!0) #b1)) (not (= (cmp1 x!0) #b0)))))
      (or (= (cmp x!0) #b0) (not a!1))))))
(define-fun land.lhs.true ((x!0 (_ BitVec 32))) Bool
  (= (ite (bvule #x80000000 x!0) #x80000000 #x00000000) #x00000000))
(define-fun if.then ((x!0 (_ BitVec 32))) Bool
  (ite (= x!0 #x00000000) true
  (ite (= x!0 #x80000000) false
    (let ((a!1 (or (not (= (cmp x!0) #b1)) (not (= (cmp1 x!0) #b1)))))
      (not a!1)))))
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  (ite (= x!0 #x80000000) #xffffffff80000000
    (concat ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            ((_ extract 31 31) x!0)
            x!0)))
    visit br
  <BB> return
$$$ BB cond: (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
      (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (or (and true (= (cmp i) #b0)) a!1 a!2))
    visit phi
tar: (%0 i)branch cond: (if.then i)
tar: #xffffffffbranch cond: (if.else i)
---------
<Func> bar3: arg i
  <BB> entry
$$$ BB cond: true
    visit icmp
    visit br
  <BB> land.lhs.true
$$$ BB cond: (and true (= (cmp i) #b1))
    visit icmp
    visit br
  <BB> if.else
$$$ BB cond: (or (and true (= (cmp i) #b0)) (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))
    visit br
  <BB> if.then
$$$ BB cond: (and true (= (cmp i) #b1) (= (cmp1 i) #b1))
    visit br
  <BB> if.end
$$$ BB cond: (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
      (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (or (and true (= (cmp i) #b0)) a!1 a!2))
    visit phi
tar: ibranch cond: (if.then i)
tar: #x00000000branch cond: (if.else i)
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun land.lhs.true ((_ BitVec 32)) Bool)
(declare-fun cmp1 ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun if.end ((_ BitVec 32)) Bool)
(declare-fun x.0 ((_ BitVec 32)) (_ BitVec 32))
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(declare-fun i () (_ BitVec 32))
(assert (forall ((i (_ BitVec 32))) (= (entry i) true)))
(assert (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0))))
(assert (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (and true (= (cmp i) #b1)))))
(assert (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (or (and true (= (cmp i) #b0))
                 (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
    (= (if.else i) a!1))))
(assert (forall ((i (_ BitVec 32)))
  (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
        (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (let ((a!3 (or (and true (= (cmp i) #b0)) a!1 a!2)))
    (= (if.end i) a!3)))))
(assert (forall ((i (_ BitVec 32))) (=> (if.then i) (= (x.0 i) i))))
(assert (forall ((i (_ BitVec 32))) (=> (if.else i) (= (x.0 i) #x00000000))))
(assert (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (x.0 i)))))
(assert (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
      (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
  (or (and true (= (cmp i) #b0)) a!1 a!2)))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (entry i) true))
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (and true (= (cmp i) #b1))))
  (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (or (and true (= (cmp i) #b0))
                   (and true (= (cmp i) #b1) (= (cmp1 i) #b0)))))
      (= (if.else i) a!1)))
  (forall ((i (_ BitVec 32)))
    (= (if.then i) (and true (= (cmp i) #b1) (= (cmp1 i) #b1))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
          (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
    (let ((a!3 (or (and true (= (cmp i) #b0)) a!1 a!2)))
      (= (if.end i) a!3))))
  (forall ((i (_ BitVec 32))) (=> (if.then i) (= (x.0 i) i)))
  (forall ((i (_ BitVec 32))) (=> (if.else i) (= (x.0 i) #x00000000)))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (x.0 i))))
  (let ((a!1 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b0)))
        (a!2 (and (and true (= (cmp i) #b1)) (= (cmp1 i) #b1))))
    (or (and true (= (cmp i) #b0)) a!1 a!2))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x00000001)
(define-fun k!186 ((x!0 (_ BitVec 32))) (_ BitVec 32)
  (let ((a!1 (ite (bvule #x00000410 x!0)
                  (ite (bvule #x00000440 x!0)
                       (ite (bvule #x80000000 x!0) #x80000000 #x00000440)
                       #x00000410)
                  #x00000408)))
  (let ((a!2 (ite (bvule #x00000402 x!0)
                  (ite (bvule #x00000404 x!0)
                       (ite (bvule #x00000408 x!0) a!1 #x00000404)
                       #x00000402)
                  #x00000401)))
    (ite (bvule #x00000001 x!0)
         (ite (bvule #x00000400 x!0)
              (ite (bvule #x00000401 x!0) a!2 #x00000400)
              #x00000001)
         #x00000000))))
(define-fun if.else ((x!0 (_ BitVec 32))) Bool
  (or (= (k!186 x!0) #x00000401)
      (= (k!186 x!0) #x00000402)
      (= (k!186 x!0) #x00000404)
      (= (k!186 x!0) #x00000408)
      (= (k!186 x!0) #x00000410)
      (= (k!186 x!0) #x00000440)
      (= (k!186 x!0) #x80000000)))
(define-fun land.lhs.true ((x!0 (_ BitVec 32))) Bool
  (or (= (k!186 x!0) #x00000001)
      (= (k!186 x!0) #x00000400)
      (= (k!186 x!0) #x00000401)
      (= (k!186 x!0) #x00000402)
      (= (k!186 x!0) #x00000404)
      (= (k!186 x!0) #x00000408)
      (= (k!186 x!0) #x00000410)
      (= (k!186 x!0) #x00000440)
      (= (k!186 x!0) #x00000000)))
(define-fun cmp ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (let ((a!1 (ite (= (k!186 x!0) #x00000000)
                  #b1
                  (ite (= (k!186 x!0) #x00000001) #b1 #b0))))
  (let ((a!2 (ite (= (k!186 x!0) #x00000440)
                  #b1
                  (ite (= (k!186 x!0) #x00000400) #b1 a!1))))
  (let ((a!3 (ite (= (k!186 x!0) #x00000408)
                  #b1
                  (ite (= (k!186 x!0) #x00000410) #b1 a!2))))
  (let ((a!4 (ite (= (k!186 x!0) #x00000402)
                  #b1
                  (ite (= (k!186 x!0) #x00000404) #b1 a!3))))
    (ite (= (k!186 x!0) #x00000401) #b1 a!4))))))
(define-fun cmp1 ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (let ((a!1 (ite (= (k!186 x!0) #x00000000)
                  #b1
                  (ite (= (k!186 x!0) #x00000001) #b1 #b0))))
    (ite (= (k!186 x!0) #x80000000)
         #b1
         (ite (= (k!186 x!0) #x00000400) #b1 a!1))))
(define-fun if.end ((x!0 (_ BitVec 32))) Bool
  (ite (= x!0 #x00000000) true
  (ite (= x!0 #x00000400) true
  (ite (= x!0 #x80000000) true
  (ite (= x!0 #x00000440) true
  (ite (= x!0 #x00000410) true
  (ite (= x!0 #x00000408) true
  (ite (= x!0 #x00000404) true
  (ite (= x!0 #x00000402) true
  (ite (= x!0 #x00000401) true
  (ite (= x!0 #x00000001) true
    (let ((a!1 (or (not (= (cmp x!0) #b1)) (not (= (cmp1 x!0) #b0))))
          (a!2 (or (not (= (cmp x!0) #b1)) (not (= (cmp1 x!0) #b1)))))
      (or (= (cmp x!0) #b0) (not a!1) (not a!2))))))))))))))
(define-fun x.0 ((x!0 (_ BitVec 32))) (_ BitVec 32)
  (ite (= x!0 #x00000001) #x00000001
  (ite (= x!0 #x00000000) #x00000000
  (ite (= x!0 #x00000400) #x00000400
  (ite (= x!0 #x80000000) #x00000000
  (ite (= x!0 #x00000440) #x00000000
  (ite (= x!0 #x00000410) #x00000000
  (ite (= x!0 #x00000408) #x00000000
  (ite (= x!0 #x00000404) #x00000000
  (ite (= x!0 #x00000402) #x00000000
  (ite (= x!0 #x00000401) #x00000000
    (ite (if.else x!0) #x00000000 x!0))))))))))))
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  (ite (= x!0 #x00000000) #x0000000000000000
  (ite (= x!0 #x80000000) #x0000000000000000
  (ite (= x!0 #x00000440) #x0000000000000000
  (ite (= x!0 #x00000410) #x0000000000000000
  (ite (= x!0 #x00000408) #x0000000000000000
  (ite (= x!0 #x00000404) #x0000000000000000
  (ite (= x!0 #x00000402) #x0000000000000000
  (ite (= x!0 #x00000401) #x0000000000000000
  (ite (= x!0 #x00000400) #x0000000000000400
  (ite (= x!0 #x00000001) #x0000000000000001
    (concat ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            ((_ extract 31 31) (x.0 x!0))
            (x.0 x!0)))))))))))))
(define-fun if.then ((x!0 (_ BitVec 32))) Bool
  (or (= (k!186 x!0) #x00000001)
      (= (k!186 x!0) #x00000400)
      (= (k!186 x!0) #x00000000)))
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
---------
<Func> interproc: arg i
  <BB> entry
$$$ BB cond: true
    visit icmp
    visit br
  <BB> if.else
$$$ BB cond: (and true (= (cmp i) #b0))
    visit br
  <BB> if.then
$$$ BB cond: (and true (= (cmp i) #b1))
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun call ((_ BitVec 32)) (_ BitVec 32))
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(declare-fun i () (_ BitVec 32))
(assert (forall ((i (_ BitVec 32))) (= (entry i) true)))
(assert (forall ((i (_ BitVec 32)))
  (= (cmp i) (ite (bvslt (call i) #x00000400) #b1 #b0))))
(assert (forall ((i (_ BitVec 32))) (= (if.else i) (and true (= (cmp i) #b0)))))
(assert (forall ((i (_ BitVec 32))) (= (if.then i) (and true (= (cmp i) #b1)))))
(assert (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (call i)))))
(assert (and true (= (cmp i) #b1)))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (entry i) true))
  (forall ((i (_ BitVec 32)))
    (= (cmp i) (ite (bvslt (call i) #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (and true (= (cmp i) #b0))))
  (forall ((i (_ BitVec 32))) (= (if.then i) (and true (= (cmp i) #b1))))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (call i))))
  (and true (= (cmp i) #b1))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x00000000)
(define-fun if.else ((x!0 (_ BitVec 32))) Bool
  false)
(define-fun cmp ((x!0 (_ BitVec 32))) (_ BitVec 1)
  #b1)
(define-fun if.then ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun call ((x!0 (_ BitVec 32))) (_ BitVec 32)
  #x80000000)
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  (ite (= x!0 #x00000000) #xffffffff80000000
    (concat ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            (call x!0))))
    visit br
  <BB> return
$$$ BB cond: (or (and true (= (cmp i) #b0)) (and true (= (cmp i) #b1)))
    visit phi
tar: (%0 i)branch cond: (if.then i)
tar: #xffffffffbranch cond: (if.else i)
