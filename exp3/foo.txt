new z3walker
<Module> test/foo.ll, size is 8
---------
<Func> abs: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sub
    visit br
  <BB> if.end
    visit phi
---------
<Func> foo1: arg i
  <BB> entry
    visit and
    visit sext
    visit gep
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (and i) (bvand i #x000003ff)))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (and i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
---------
<Func> foo2: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (cmp i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvslt i #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (if.then i) (cmp1 i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp1 i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (return i) #b1))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) i)))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
    visit br
  <BB> return
    visit phi
---------
<Func> foo3: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit br
  <BB> if.end
    visit phi
    visit sext
    visit gep
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (cmp i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvslt i #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (if.then i) (cmp1 i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp1 i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (if.end i) #b1))
  (forall ((i (_ BitVec 32))) (= (if.end i) #b1))
  (forall ((i (_ BitVec 32))) (=> (= (if.then i) #b1) (= (x.0 i) i)))
  (forall ((i (_ BitVec 32))) (=> (= (if.else i) #b1) (= (x.0 i) #x00000000)))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (x.0 i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
---------
<Func> bar1: arg i
  <BB> entry
    visit and
    visit sext
    visit gep
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (and i) (bvand i #x000007ff)))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (and i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun and ((x!0 (_ BitVec 32))) (_ BitVec 32)
  (ite (= x!0 #x00000400) #x00000400
    (concat #b000000000000000000000 ((_ extract 10 0) x!0))))
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  (ite (= x!0 #x00000400) #x0000000000000400
    (concat ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            (and x!0))))
---------
<Func> bar2: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (cmp i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (if.then i) (cmp1 i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp1 i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (return i) #b1))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) i)))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
    visit br
  <BB> return
    visit phi
---------
<Func> bar3: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit br
  <BB> if.end
    visit phi
    visit sext
    visit gep
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsge i #x00000000) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (land.lhs.true i) (cmp i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (if.then i) (cmp1 i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp1 i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (if.end i) #b1))
  (forall ((i (_ BitVec 32))) (= (if.end i) #b1))
  (forall ((i (_ BitVec 32))) (=> (= (if.then i) #b1) (= (x.0 i) i)))
  (forall ((i (_ BitVec 32))) (=> (= (if.else i) #b1) (= (x.0 i) #x00000000)))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (x.0 i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
---------
<Func> interproc: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32)))
    (= (cmp i) (ite (bvslt (call i) #x00000400) #b1 #b0)))
  (forall ((i (_ BitVec 32))) (= (if.then i) (cmp i)))
  (forall ((i (_ BitVec 32))) (= (if.else i) (ite (= (cmp i) #b1) #b0 #b1)))
  (forall ((i (_ BitVec 32))) (= (return i) #b1))
  (forall ((i (_ BitVec 32))) (= (idxprom i) ((_ sign_extend 32) (call i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun return ((x!0 (_ BitVec 32))) (_ BitVec 1)
  #b1)
(define-fun call ((x!0 (_ BitVec 32))) (_ BitVec 32)
  #x80000000)
(define-fun cmp ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (ite (= x!0 #x00000000) #b1
    (ite (bvsle #x00000400 (call x!0)) #b0 #b1)))
(define-fun if.else ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (ite (= x!0 #x00000000) #b0
    (ite (= (cmp x!0) #b1) #b0 #b1)))
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  (ite (= x!0 #x00000000) #xffffffff80000000
    (concat ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            ((_ extract 31 31) (call x!0))
            (call x!0))))
(define-fun if.then ((x!0 (_ BitVec 32))) (_ BitVec 1)
  (ite (= x!0 #x00000000) #b1
    (cmp x!0)))
    visit br
  <BB> return
    visit phi
