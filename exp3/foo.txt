new z3walker
<Module> test/foo.ll, size is 8
---------
<Func> abs: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sub
    visit br
  <BB> if.end
    visit phi
tar: (sub i)branch cond: (if.then i)
tar: ibranch cond: (if.else i)
---------
<Func> foo1: arg i
  <BB> entry
    visit and
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun and ((_ BitVec 32)) (_ BitVec 32))
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (entry i)))
(assert (forall ((i (_ BitVec 32)))
  (= (and i) (concat #b0000000000000000000000 ((_ extract 9 0) i)))))
(assert (forall ((i (_ BitVec 32)))
  (= (idxprom i)
     (concat ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             (and i)))))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (entry i))
  (forall ((i (_ BitVec 32)))
    (= (and i) (concat #b0000000000000000000000 ((_ extract 9 0) i))))
  (forall ((i (_ BitVec 32)))
    (= (idxprom i)
       (concat ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               (and i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
---------
<Func> foo2: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun land.lhs.true ((_ BitVec 32)) Bool)
(declare-fun cmp1 ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (entry i)))
(assert (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsle #x00000000 i) #b1 #b0))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp i) (ite (land.lhs.true i) #b1 #b0)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp1 i) (ite (bvsle #x00000400 i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (= (if.then i) (and (= (cmp i) #b1) (= (cmp1 i) #b1)))))
    (and (= (cmp i) #b1) (= (cmp1 i) #b1) a!1))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1)
       (= (cmp1 i) #b1)
       (= (idxprom i)
          (concat ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  i)))))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (entry i))
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsle #x00000000 i) #b1 #b0)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp i) (ite (land.lhs.true i) #b1 #b0))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp1 i) (ite (bvsle #x00000400 i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (= (if.then i) (and (= (cmp i) #b1) (= (cmp1 i) #b1)))))
      (and (= (cmp i) #b1) (= (cmp1 i) #b1) a!1)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1)
         (= (cmp1 i) #b1)
         (= (idxprom i)
            (concat ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
    visit br
  <BB> return
    visit phi
tar: (%0 i)branch cond: (if.then i)
tar: #xffffffffbranch cond: (if.else i)
---------
<Func> foo3: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit br
  <BB> if.end
    visit phi
tar: ibranch cond: (if.then i)
tar: #x00000000branch cond: (if.else i)
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun land.lhs.true ((_ BitVec 32)) Bool)
(declare-fun cmp1 ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun if.end ((_ BitVec 32)) Bool)
(declare-fun x.0 ((_ BitVec 32)) (_ BitVec 32))
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (entry i)))
(assert (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsle #x00000000 i) #b1 #b0))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp i) (ite (land.lhs.true i) #b1 #b0)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp1 i) (ite (bvsle #x00000400 i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (= (if.then i) (and (= (cmp i) #b1) (= (cmp1 i) #b1)))))
    (and (= (cmp i) #b1) (= (cmp1 i) #b1) a!1))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (= (cmp i) (ite (if.end i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (or (not (if.then i)) (= (x.0 i) i)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (or (not (if.else i)) (= (x.0 i) #x00000000)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (= (idxprom i)
                (concat ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        (x.0 i)))))
    (and (= (cmp i) #b0) a!1))))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (entry i))
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsle #x00000000 i) #b1 #b0)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp i) (ite (land.lhs.true i) #b1 #b0))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp1 i) (ite (bvsle #x00000400 i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (= (if.then i) (and (= (cmp i) #b1) (= (cmp1 i) #b1)))))
      (and (= (cmp i) #b1) (= (cmp1 i) #b1) a!1)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (= (cmp i) (ite (if.end i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (or (not (if.then i)) (= (x.0 i) i))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (or (not (if.else i)) (= (x.0 i) #x00000000))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (= (idxprom i)
                  (concat ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          (x.0 i)))))
      (and (= (cmp i) #b0) a!1)))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
---------
<Func> bar1: arg i
  <BB> entry
    visit and
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun and ((_ BitVec 32)) (_ BitVec 32))
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (entry i)))
(assert (forall ((i (_ BitVec 32)))
  (= (and i) (concat #b000000000000000000000 ((_ extract 10 0) i)))))
(assert (forall ((i (_ BitVec 32)))
  (= (idxprom i)
     (concat ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             ((_ extract 31 31) (and i))
             (and i)))))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (entry i))
  (forall ((i (_ BitVec 32)))
    (= (and i) (concat #b000000000000000000000 ((_ extract 10 0) i))))
  (forall ((i (_ BitVec 32)))
    (= (idxprom i)
       (concat ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               ((_ extract 31 31) (and i))
               (and i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun and ((x!0 (_ BitVec 32))) (_ BitVec 32)
  (ite (= x!0 #x00000400) #x00000400
    (concat #b000000000000000000000 ((_ extract 10 0) x!0))))
(define-fun entry ((x!0 (_ BitVec 32))) Bool
  true)
(define-fun idxprom ((x!0 (_ BitVec 32))) (_ BitVec 64)
  (ite (= x!0 #x00000400) #x0000000000000400
    (concat ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            ((_ extract 31 31) (and x!0))
            (and x!0))))
---------
<Func> bar2: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun land.lhs.true ((_ BitVec 32)) Bool)
(declare-fun cmp1 ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (entry i)))
(assert (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsle #x00000000 i) #b1 #b0))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp i) (ite (land.lhs.true i) #b1 #b0)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (= (if.then i) (and (= (cmp i) #b1) (= (cmp1 i) #b1)))))
    (and (= (cmp i) #b1) (= (cmp1 i) #b1) a!1))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1)
       (= (cmp1 i) #b1)
       (= (idxprom i)
          (concat ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  ((_ extract 31 31) i)
                  i)))))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (entry i))
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsle #x00000000 i) #b1 #b0)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp i) (ite (land.lhs.true i) #b1 #b0))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (= (if.then i) (and (= (cmp i) #b1) (= (cmp1 i) #b1)))))
      (and (= (cmp i) #b1) (= (cmp1 i) #b1) a!1)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1)
         (= (cmp1 i) #b1)
         (= (idxprom i)
            (concat ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    ((_ extract 31 31) i)
                    i))))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
    visit br
  <BB> return
    visit phi
tar: (%0 i)branch cond: (if.then i)
tar: #xffffffffbranch cond: (if.else i)
---------
<Func> bar3: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit br
  <BB> if.end
    visit phi
tar: ibranch cond: (if.then i)
tar: #x00000000branch cond: (if.else i)
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun land.lhs.true ((_ BitVec 32)) Bool)
(declare-fun cmp1 ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun if.end ((_ BitVec 32)) Bool)
(declare-fun x.0 ((_ BitVec 32)) (_ BitVec 32))
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (entry i)))
(assert (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsle #x00000000 i) #b1 #b0))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp i) (ite (land.lhs.true i) #b1 #b0)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (= (if.then i) (and (= (cmp i) #b1) (= (cmp1 i) #b1)))))
    (and (= (cmp i) #b1) (= (cmp1 i) #b1) a!1))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (= (cmp i) (ite (if.end i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (or (not (if.then i)) (= (x.0 i) i)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (or (not (if.else i)) (= (x.0 i) #x00000000)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (= (idxprom i)
                (concat ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        ((_ extract 31 31) (x.0 i))
                        (x.0 i)))))
    (and (= (cmp i) #b0) a!1))))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (entry i))
  (forall ((i (_ BitVec 32))) (= (cmp i) (ite (bvsle #x00000000 i) #b1 #b0)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp i) (ite (land.lhs.true i) #b1 #b0))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp1 i) (ite (bvsle i #x00000400) #b1 #b0))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (= (if.then i) (and (= (cmp i) #b1) (= (cmp1 i) #b1)))))
      (and (= (cmp i) #b1) (= (cmp1 i) #b1) a!1)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (= (cmp i) (ite (if.end i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (or (not (if.then i)) (= (x.0 i) i))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (or (not (if.else i)) (= (x.0 i) #x00000000))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (= (idxprom i)
                  (concat ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          ((_ extract 31 31) (x.0 i))
                          (x.0 i)))))
      (and (= (cmp i) #b0) a!1)))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
---------
<Func> interproc: arg i
  <BB> entry
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
----<solver>--------
(declare-fun entry ((_ BitVec 32)) Bool)
(declare-fun call ((_ BitVec 32)) (_ BitVec 32))
(declare-fun cmp ((_ BitVec 32)) (_ BitVec 1))
(declare-fun if.else ((_ BitVec 32)) Bool)
(declare-fun if.then ((_ BitVec 32)) Bool)
(declare-fun idxprom ((_ BitVec 32)) (_ BitVec 64))
(assert (forall ((i (_ BitVec 32))) (entry i)))
(assert (forall ((i (_ BitVec 32)))
  (= (cmp i) (ite (bvsle #x00000400 (call i)) #b0 #b1))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1)))))
(assert (forall ((i (_ BitVec 32)))
  (and (= (cmp i) #b1) (= (cmp i) (ite (if.then i) #b1 #b0)))))
(assert (forall ((i (_ BitVec 32)))
  (let ((a!1 (= (idxprom i)
                (concat ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        ((_ extract 31 31) (call i))
                        (call i)))))
    (and (= (cmp i) #b1) a!1))))
(assert (let ((a!1 (forall ((i (_ BitVec 32)))
             (and (bvsge (idxprom i) #x0000000000000000)
                  (bvslt (idxprom i) #x0000000000000400)))))
  (not a!1)))

-------------
Checking with assertions:
(ast-vector
  (forall ((i (_ BitVec 32))) (entry i))
  (forall ((i (_ BitVec 32)))
    (= (cmp i) (ite (bvsle #x00000400 (call i)) #b0 #b1)))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b0) (= (cmp i) (ite (if.else i) #b0 #b1))))
  (forall ((i (_ BitVec 32)))
    (and (= (cmp i) #b1) (= (cmp i) (ite (if.then i) #b1 #b0))))
  (forall ((i (_ BitVec 32)))
    (let ((a!1 (= (idxprom i)
                  (concat ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          ((_ extract 31 31) (call i))
                          (call i)))))
      (and (= (cmp i) #b1) a!1)))
  (let ((a!1 (forall ((i (_ BitVec 32)))
               (and (bvsge (idxprom i) #x0000000000000000)
                    (bvslt (idxprom i) #x0000000000000400)))))
    (not a!1)))
GEP arrayidx is safe.
    visit br
  <BB> return
    visit phi
tar: (%0 i)branch cond: (if.then i)
tar: #xffffffffbranch cond: (if.else i)
