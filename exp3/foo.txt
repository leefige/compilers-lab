Now walking the module...
new z3walker
<Module> test/foo.ll, size is 8
<Func> abs: ; arg i
  <BB> entry
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sub
    visit br
  <BB> if.end
    visit phi
------------
<Solver>
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun sub () (_ BitVec 32))
(assert (= cmp (ite (bvslt i #x00000000) #b1 #b0)))
(assert (= sub (bvsub #x00000000 i)))
============
<Func> foo1: ; arg i
  <BB> entry
    visit and
    visit sext
    visit gep
===check pushed===
(declare-fun i () (_ BitVec 32))
(declare-fun and () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= and (bvand i #x000003ff)))
(assert (= idxprom ((_ sign_extend 32) and)))

bound added
(declare-fun i () (_ BitVec 32))
(declare-fun and () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= and (bvand i #x000003ff)))
(assert (= idxprom ((_ sign_extend 32) and)))
(assert (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))

Checking with assertions:
(ast-vector
  (= and (bvand i #x000003ff))
  (= idxprom ((_ sign_extend 32) and))
  (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))
GEP arrayidx is safe.
===check popped===
------------
<Solver>
(declare-fun i () (_ BitVec 32))
(declare-fun and () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= and (bvand i #x000003ff)))
(assert (= idxprom ((_ sign_extend 32) and)))
============
<Func> foo2: ; arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
===check pushed===
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvslt i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) i)))

bound added
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvslt i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) i)))
(assert (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))

Checking with assertions:
(ast-vector
  (= cmp (ite (bvsge i #x00000000) #b1 #b0))
  (= cmp1 (ite (bvslt i #x00000400) #b1 #b0))
  (= idxprom ((_ sign_extend 32) i))
  (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x80000000)
(define-fun cmp () (_ BitVec 1)
  #b0)
(define-fun cmp1 () (_ BitVec 1)
  #b1)
(define-fun idxprom () (_ BitVec 64)
  #xffffffff80000000)
===check popped===
    visit br
  <BB> return
    visit phi
------------
<Solver>
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvslt i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) i)))
============
<Func> foo3: ; arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit br
  <BB> if.end
    visit phi
    visit sext
    visit gep
===check pushed===
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun x.0 () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvslt i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) x.0)))

bound added
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun x.0 () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvslt i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) x.0)))
(assert (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))

Checking with assertions:
(ast-vector
  (= cmp (ite (bvsge i #x00000000) #b1 #b0))
  (= cmp1 (ite (bvslt i #x00000400) #b1 #b0))
  (= idxprom ((_ sign_extend 32) x.0))
  (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x80000000)
(define-fun cmp () (_ BitVec 1)
  #b0)
(define-fun cmp1 () (_ BitVec 1)
  #b1)
(define-fun idxprom () (_ BitVec 64)
  #xffffffff80000000)
(define-fun x.0 () (_ BitVec 32)
  #x80000000)
===check popped===
------------
<Solver>
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun x.0 () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvslt i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) x.0)))
============
<Func> bar1: ; arg i
  <BB> entry
    visit and
    visit sext
    visit gep
===check pushed===
(declare-fun i () (_ BitVec 32))
(declare-fun and () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= and (bvand i #x000007ff)))
(assert (= idxprom ((_ sign_extend 32) and)))

bound added
(declare-fun i () (_ BitVec 32))
(declare-fun and () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= and (bvand i #x000007ff)))
(assert (= idxprom ((_ sign_extend 32) and)))
(assert (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))

Checking with assertions:
(ast-vector
  (= and (bvand i #x000007ff))
  (= idxprom ((_ sign_extend 32) and))
  (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x00000400)
(define-fun and () (_ BitVec 32)
  #x00000400)
(define-fun idxprom () (_ BitVec 64)
  #x0000000000000400)
===check popped===
------------
<Solver>
(declare-fun i () (_ BitVec 32))
(declare-fun and () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= and (bvand i #x000007ff)))
(assert (= idxprom ((_ sign_extend 32) and)))
============
<Func> bar2: ; arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
===check pushed===
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvsle i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) i)))

bound added
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvsle i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) i)))
(assert (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))

Checking with assertions:
(ast-vector
  (= cmp (ite (bvsge i #x00000000) #b1 #b0))
  (= cmp1 (ite (bvsle i #x00000400) #b1 #b0))
  (= idxprom ((_ sign_extend 32) i))
  (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x80000000)
(define-fun cmp () (_ BitVec 1)
  #b0)
(define-fun cmp1 () (_ BitVec 1)
  #b1)
(define-fun idxprom () (_ BitVec 64)
  #xffffffff80000000)
===check popped===
    visit br
  <BB> return
    visit phi
------------
<Solver>
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvsle i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) i)))
============
<Func> bar3: ; arg i
  <BB> entry
    visit icmp
    visit br
  <BB> land.lhs.true
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit br
  <BB> if.end
    visit phi
    visit sext
    visit gep
===check pushed===
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun x.0 () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvsle i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) x.0)))

bound added
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun x.0 () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvsle i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) x.0)))
(assert (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))

Checking with assertions:
(ast-vector
  (= cmp (ite (bvsge i #x00000000) #b1 #b0))
  (= cmp1 (ite (bvsle i #x00000400) #b1 #b0))
  (= idxprom ((_ sign_extend 32) x.0))
  (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun i () (_ BitVec 32)
  #x80000401)
(define-fun cmp () (_ BitVec 1)
  #b0)
(define-fun cmp1 () (_ BitVec 1)
  #b1)
(define-fun idxprom () (_ BitVec 64)
  #xffffffff80000000)
(define-fun x.0 () (_ BitVec 32)
  #x80000000)
===check popped===
------------
<Solver>
(declare-fun i () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun cmp1 () (_ BitVec 1))
(declare-fun x.0 () (_ BitVec 32))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvsge i #x00000000) #b1 #b0)))
(assert (= cmp1 (ite (bvsle i #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) x.0)))
============
<Func> interproc: ; arg i
  <BB> entry
    visit icmp
    visit br
  <BB> if.else
    visit br
  <BB> if.then
    visit sext
    visit gep
===check pushed===
(declare-fun call () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvslt call #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) call)))

bound added
(declare-fun call () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvslt call #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) call)))
(assert (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))

Checking with assertions:
(ast-vector
  (= cmp (ite (bvslt call #x00000400) #b1 #b0))
  (= idxprom ((_ sign_extend 32) call))
  (not (and (bvsge idxprom #x0000000000000000) (bvslt idxprom #x0000000000000400))))
GEP arrayidx is potentially out of bound.
Model causing out of bound:
(define-fun cmp () (_ BitVec 1)
  #b0)
(define-fun call () (_ BitVec 32)
  #x40000000)
(define-fun idxprom () (_ BitVec 64)
  #x0000000040000000)
===check popped===
    visit br
  <BB> return
    visit phi
------------
<Solver>
(declare-fun call () (_ BitVec 32))
(declare-fun cmp () (_ BitVec 1))
(declare-fun idxprom () (_ BitVec 64))
(assert (= cmp (ite (bvslt call #x00000400) #b1 #b0)))
(assert (= idxprom ((_ sign_extend 32) call)))
============
